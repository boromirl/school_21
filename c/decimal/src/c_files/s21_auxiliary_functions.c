#include "../s21_decimal.h"

int get_bit(unsigned int src, int ind) {
  int mask = 1 << ind;  // маска с одной 1 и остальными нулями
  return (mask & src) >>
         ind;  // применяет маску к исходному числу, чтобы извлечь нужный бит
}
/*для получения значения бита по заданному индексу*/
int get_mantissa(s21_decimal decimal, int ind) {
  int bit = -1;

  if (ind >= 0 && ind <= 31)  // если индекс в одном из 3-х элементов битс,
                              // получаем бит из нужного элемента
    bit = get_bit(decimal.bits[0], ind);
  else if (ind >= 32 && ind <= 63)
    bit = get_bit(decimal.bits[1], ind - 32);
  else if (ind >= 64 && ind <= 95)
    bit = get_bit(decimal.bits[2], ind - 64);

  return bit;
}
/*для получения значения бита в мантессе числа децимал по заданному индексу */
// получение значение бита во всем биг децимал по индексу
int get_bit_big(s21_big_decimal b_dec, int ind) {
  int bit = -1;

  if (ind >= 0 && ind <= 31)  // аналогично функции выше для получения бита по
                              // индексу в нужно элементе
    bit = get_bit(b_dec.bits[0], ind);
  else if (ind >= 32 && ind <= 63)
    bit = get_bit(b_dec.bits[1], ind - 32);
  else if (ind >= 64 && ind <= 95)
    bit = get_bit(b_dec.bits[2], ind - 64);
  else if (ind >= 96 && ind <= 127)
    bit = get_bit(b_dec.bits[3], ind - 96);
  else if (ind >= 128 && ind <= 159)
    bit = get_bit(b_dec.bits[4], ind - 128);
  else if (ind >= 160 && ind <= 191)
    bit = get_bit(b_dec.bits[5], ind - 160);
  else if (ind >= 192 && ind <= 223)
    bit = get_bit(b_dec.bits[6], ind - 192);

  return bit;
}

// Установить зачение одного бита в инте по индексу
void set_bit(unsigned int *src, int ind,
             int value) {  // число в котором нужно установить бит, индекс бита,
                           // который нужно установить, значение которое нужно
                           // установить (0 или 1)
  int mask = 1 << ind;  // маска для сдвига 1 влево на инд позиций

  if (value == 1) {
    *src |= mask;  // чтобы уставить нужный бит, сохранив другие биты
  }
  if (value == 0) {
    *src &= (~mask);  // а это чтобы сбросить нужный бит в позиции инд, не
                      // трогая другие биты
  }
}

// Установить значение бита в мантиссе (bits[0-2]) по индексу (0-95)
void set_mantissa(s21_decimal *src, int ind, int value) {
  if (ind >= 0 && ind <= 31)
    set_bit(&(src->bits[0]), ind, value);
  else if (ind >= 32 && ind <= 63)
    set_bit(&(src->bits[1]), ind - 32, value);
  else if (ind >= 64 && ind <= 95)
    set_bit(&(src->bits[2]), ind - 64, value);
}

bool test_bit(
    unsigned int value,
    int BitNumber) {  // беззнаковое целое число в котором проверяется бит,
                      // номер бита, значение которого нужно проверить
  return (value & (1u << BitNumber)) !=
         0;  // побитовая операция И и побитовый сдвиг влево для проверки
             // конкретного бита, 1u - unsigned int, чтобы не было
             // неопределенного поведения при побитовых операциях
}  // возвращает true, если бит = 1, false если 0

/*для проверки значения конкретного бита в числе.
Принцип работы - создание маски, в ней бит под номером BitNumber
установлен в 1, далее применение побитовой операции И между value
и маской, сверка результата неравенства с 0, чтобы определить
установлен ли бит. 1u << BitNumber - сдвиг единицы типа unsigned int
на BitNumber позиций, далее побитовая операция И между value и маской
все биты кроме BitNumber становятся = 0, далее сравнение
результата с 0, true - если бит установлен (= 1), false - не
установлен (= 0). Отличие от get_bit в том, что возвращает именно логическое
значение, а не просто конкретное значение бита (0 или 1), впрочем,
можно использовать и get_bit*/

int get_sign(s21_decimal *num) {  // указатель на переменную децимал
  int res = -1;  // -1 так как неопределенное состояние;
  if (test_bit(num->bits[3], 31) ==
      0) {  // обращение к четвертому элементу массива bits (bits[3]) и проверка
            // значения 31-го бита, чтобы определить знак числа
    res = 0;  // если число положительное
  } else {
    res = 1;  // если отрицательное
  }
  return res;
}
/*для определения знака числа, проверяет 31-й бит четвертого
элемента массива bits (bits[3]), если бит равен 0 - число
положительное, если 1 - отрицательное*/

// установление знака в decimal
void set_sign(s21_decimal *decimal, int sign) {
  set_bit(&(decimal->bits[3]), 31, sign);
}

// Узнать степень, которая указывает на положение запятой в decimal
int get_scale(s21_decimal decimal) {
  int mask = 0b11111111 << 16;  // маска для извлечения скейла
  return (decimal.bits[3] & mask) >>
         16;  // применение маски к 4-му массиву битс и сдвиг их на 16 позиций
              // влево, чтобы получить фактическое значение скейла
}

//  Установить степень
void set_scale(s21_decimal *decimal, unsigned int scale) {
  scale = scale << 16;  // сдвиг значения скейл влево, чтобы подготовить к
                        // установке в 4-м элементе битс
  for (int i = 16; i <= 23; i++) {  // итерация по 16-23 массивам 4-го битс
    set_bit(&(decimal->bits[3]), i,
            get_bit(scale, i));  // установка нужных битов по битам из скейл
  }
}

// Заполнение децимала нулями
void zero_decimal(s21_decimal *decimal) {
  for (int i = 0; i < 4; i++) {  // итерация по всем элементам массива битс и
                                 // обнуление битов в них
    decimal->bits[i] = 0u;  // суффикс u - значит unsigned (возможно излишне и
                            // можно заменить на простой 0)
  }
}

// заполнение big decimal нулями
void zero_big_decimal(
    s21_big_decimal *big_decimal) {  // указатель на структуру, которую нужно
                                     // полностью обнулить
  big_decimal->sign =
      0;  // обнуление знака числа, доступ к элементу структуры через указатель
  big_decimal->scale = 0;  // обнуление скейл

  for (int i = 0; i < 7; i++) {  // цикл обнуление всех битов элементов массива
    big_decimal->bits[i] =
        0ULL;  // суффикс ULL - означает, что число uint64 (возможно излишне и
               // можно заменить на простой 0)
  }
}

// перевод decimal в big_decimal
void decimal_to_big(s21_decimal src, s21_big_decimal *dst) {
  zero_big_decimal(dst);  // обнуляет структуру биг децимал
  dst->sign = get_sign(&src);   // копирование знака
  dst->scale = get_scale(src);  // копирование скейла

  for (int i = 0; i <= 2; i++) {  // итерация по элементам структуры децимал
    dst->bits[i] =
        (src.bits[i] & MAX32INT);  // операция копирования, для этого создается
                                   // маска из 32 единиц, чтобы корректно
                                   // скопировать только младшие 32 бита
  }
}

// перевод big_decimal в decimal
void big_to_decimal(s21_big_decimal src, s21_decimal *dst) {
  zero_decimal(
      dst);  // сначала структура обнуляется, чтобы копировать в нее данные
  set_scale(dst, src.scale);  // копирование экспоненты
  set_sign(dst, src.sign);    // копирование знака

  for (int i = 0; i <= 2; i++) {
    dst->bits[i] =
        (src.bits[i] & MAX32INT);  // копирование младших 32-х бит используя
                                   // маску, чтобы скопировалось корректно
  }
}

// обработка переполнения (перенос в старшие биты)
// возможно, нужно будет сделать проверку на переполнение старшего
void handle_overflow(
    s21_big_decimal
        *b_dec) {  // в этой структуре переносит переполнение из старших битов
                   // одного элемента, в младшие биты следующего элемента
  uint64_t overflow = 0;  // для хранения значений переполнения
  for (int i = 0; i < 6; i++) {  // итерация по 6 элементам структуры
    overflow = (b_dec->bits[i] & HIGHBITS) >>
               32;  // извлечение переполнения старших 32 бит
    b_dec->bits[i + 1] += overflow;  // добавление переполнения к младшим 32
                                     // битам следующего элемента
    b_dec->bits[i] &= LOWBITS;  // очиста старших 32 бит текущего элемента
  }
}
// обработка переполнения в биг децимал
void handle_high_overflow(s21_big_decimal *b_dec) {
  int remainder = 0;  // число, которое будет отрезаться
  int last_digit = 0;  // крайнее из чисел, которые останутся
  int is_all_zeroes = 1;  // флаг, что среди отрезанных чисел были только нули
  while (b_dec->bits[3] != 0 &&
         b_dec->scale != 0) {  // пока старшие элементы мантиссы бит и порядок
                               // числа не равны нулю, уменьшение порядка числа
    if (remainder != 0)
      is_all_zeroes = 0;  // если число, которое будет отрезаться не равно нулю,
                          // установление флага в 0
    remainder =
        get_last_digit_of_big(*b_dec);  // извлечение последней цифры числа и
                                        // сохранение ее в ремайндер
    change_scale(b_dec, b_dec->scale - 1);  // уменьшение порядка числа
    last_digit = get_last_digit_of_big(
        *b_dec);  // извлечение новой последней цифры числа
  }

  // проверки по банковскому округлению
  if ((remainder > 5) || (remainder == 5 && (last_digit % 2 == 1)) ||
      ((remainder == 5) &&
       !is_all_zeroes)) {  // и среди отрезанных чисел не только нули
    b_dec->bits[0]++;  // округление вверх
    handle_overflow(
        b_dec);  // на этом шаге может произойти перепеолнение (переход в
                 // недопустимый 3-й битс), но только если все биты числа = 1
  }
  // поэтому проверяем еще раз на переполнение
  if (b_dec->bits[3] != 0 && b_dec->scale != 0) {
    change_scale(b_dec, b_dec->scale - 1);
    b_dec->bits[0]++;  // прибавляем 1, так как если к самому большому числу
                       // прибавить 1, то на конце будет 6, следовательно нужно
                       // округлять вверх
  }
}

// получение последнего десятичного символа биг децимал
// функция проверяет все биты биг децимал, и использует периодичность последних
// знаков степеней двойки
int get_last_digit_of_big(s21_big_decimal b_dec) {
  int result = 0;
  if (get_bit_big(b_dec, 0) == 1)
    result += 1;  // если бит установле добавляется 1
  for (int i = 1; i <= 223; i++) {
    if (get_bit_big(b_dec,
                    i)) {  // если бит установлен добавляется соответствующая
                           // последняя цифра степени двойки
      // последние цифры степеней двойки повторяются с периодом в четыре (кроме
      // 0 степени) складывая последние цифры степеней, мы узнаем последнюю
      // цифру всего числа
      if (i % 4 == 0)
        result += 6;  // каждая 4-я степень двойки кончается на 6
      else if (i % 4 == 1)
        result += 2;  // 1-я степень двойки заканчивается на 2
      else if (i % 4 == 2)
        result += 4;  // каждая вторая степень двойки оканчивается на 4
      else if (i % 4 == 3)
        result += 8;  // каждая третья степень двойки заканчивается на 8
    }
  }
  return (result % 10);  // возврат остатка от деления на 10 - это и дает
                         // последнюю цифру числа
}

// умножение big_decimal на число БЕЗ ИЗМЕНЕНИЯ SCALE (переполнение в каждом
// элементе переносится в следующий элемент по возрастанию)
void mult_big_decimal_by_10(s21_big_decimal *b_dec) {
  uint64_t overflow =
      0;  // будет содержать переполнение от предыдущих операций умножения
  for (int i = 0; i < 7; i++) {  // итерация по всем элементам структуры
    b_dec->bits[i] *= 10;  // умножение каждого элемента на 10
    b_dec->bits[i] += (overflow >> 32);  // прибавка к результату старших 32 бит
    overflow = b_dec->bits[i] &
               HIGHBITS;  // сохранение старших бит результата умножения
                          // текущего элемента на 10 (они переносятся в
                          // следующий - старший элемент)
    b_dec->bits[i] &=
        LOWBITS;  // младшие 32 бита сохраняюется в текущем элементе
  }
}

// деление big_decimal на число БЕЗ ИЗМЕНЕНИЯ SCALE (остаток от деления
// переносится в следующий элемент по убыванию)
void div_big_decimal_by_10(s21_big_decimal *b_dec) {
  uint64_t remainder = 0;  // здесь будет отстаток от деления на каждом шаге
  for (int i = 6; i >= 0; i--) {  // итерация по всем элементам
    b_dec->bits[i] |= (remainder << 32);  // добавляем старшие биты остатка в
                                          // предыдущий(младший) элемент
    remainder = b_dec->bits[i] % 10;  // вычисляем остаток от деления на 10
    b_dec->bits[i] /= 10;  // делим текущий элемент на 10
  }
}

// изменение scale числа с умножением/делением на 10
void change_scale(s21_big_decimal *b_dec, int new_scale) {
  int cur_scale = b_dec->scale;  // текущий скейл числа
  while (cur_scale !=
         new_scale) {  // до тех пор, пока текущий скейл не равен новому скейлу
    if (cur_scale < new_scale) {  // если текущий скейл меньше нового
      mult_big_decimal_by_10(b_dec);  // увеличиваем масштаб - умножаем на 10
      cur_scale++;
    } else {
      div_big_decimal_by_10(b_dec);  // уменьшаем масштаб делим на 10
      cur_scale--;
    }
  }
  b_dec->scale = cur_scale;  // установка нового скейл
}

// Нормализация чисел (приведение к одинаковому scale)
void normalize(s21_big_decimal *b_dec1, s21_big_decimal *b_dec2) {
  if (b_dec1->scale == b_dec2->scale)
    return;  // если скейл уже одинаковый, то просто выходим из цикла и ничего
             // не делаем
  else if (b_dec1->scale > 28 ||
           b_dec2->scale >
               28) {  // если их масштаб более 28, то приводим их к скейлу 28
    change_scale(b_dec1, 28);
    change_scale(b_dec2, 28);
  } else {
    if (b_dec1->scale >
        b_dec2->scale)  // если скей первого числа больше, приводим второе число
                        // к скейлу первого
      change_scale(b_dec2, b_dec1->scale);
    else  // иначе приводим скейл первого числа к скейлу второго
      change_scale(b_dec1, b_dec2->scale);
  }
}

// перевести число в дополнительную двоичную форму (перевернуть биты и прибавить
// 1)
void make_bid_decimal_compliment(s21_big_decimal *b_dec) {
  for (int i = 0; i < 7; i++) {
    b_dec->bits[i] =
        ~(b_dec->bits[i]);  // инвертирование битов в текущем элементе
    b_dec->bits[i] &= LOWBITS;  // сохраняем только младщие 32 бита
  }
  b_dec->bits[0]++;  // прибавляем 1 к первому элементу
}

/* сравнение двух биг децимал чисел без учета знака, но с приведением к одному
скейлу (ТОЛЬКО ВНУТРИ ФУНКЦИИ! ЧИСЛА ИЗМЕНЯЮТСЯ И СРАВНИВАЮТСЯ ВНУТРИ,А ЗА
ПРЕДЕЛАМИ ФУНКЦИИ ОНИ ОСТАЮТСЯ НЕИЗМЕННЫМИ)*/
int s21_is_less_number(
    s21_big_decimal num1,
    s21_big_decimal num2) {  // два числа и результат, указатели не нужны, т.к.
                             // только сравниваем, а не меняем
  if (num1.scale != num2.scale)  // если экспонента отличается
  {
    normalize(&num1, &num2);  // привести числа к одной экспоненте
  }
  for (int i = 2; i >= 0; i--) {  // сравниваем элементы массива с 3-го по 1-й
    if (num1.bits[i] != num2.bits[i]) {  // если текущие биты не равны
      return compare_not_equal_bit(
          num1.bits[i],
          num2.bits[i]);  // возврат результата сравнения этих битов
    }
  }
  return 0;  // если все биты равны
}

/*для сравнения несовпавших битов, возвращает 1 если 1-й бит
меньше второго, иначе 0*/
int compare_not_equal_bit(uint64_t bit1, uint64_t bit2) {
  int res = 0;  // 1-й бит не меньше второго по умолчанию
  if (bit1 < bit2) {  // сравнение 2-х битов
    res = 1;          // если 1-й бит меньше второго
  }
  return res;
}

/* Функция подобная s21_is_less_number, только наоборот
сравнение двух биг децимал чисел без учета знака, но с приведением к одному
скейлу (ТОЛЬКО ВНУТРИ ФУНКЦИИ! ЧИСЛА ИЗМЕНЯЮТСЯ И СРАВНИВАЮТСЯ ВНУТРИ,А ЗА
ПРЕДЕЛАМИ ФУНКЦИИ ОНИ ОСТАЮТСЯ НЕИЗМЕННЫМИ)*/
int s21_is_greater_number(s21_big_decimal num1, s21_big_decimal num2) {
  if (num1.scale != num2.scale)  // если скейл отличается
  {
    normalize(&num1, &num2);  // привести числа к одному скейлу
  }

  for (int i = 6; i >= 0; i--) {  // сравниваем элементы массива с 3-го по 1-й
    if (num1.bits[i] != num2.bits[i]) {  // если текущие биты не равны
      return !compare_not_equal_bit(
          num1.bits[i],
          num2.bits[i]);  // возврат отрицания результата сравнения этих битов
    }
  }
  return 0;
}

int equal_bits(
    s21_big_decimal num1,
    s21_big_decimal num2) {  // здесь указатели не используются т.к. происходит
                             // только сравнение структур, а не их изменение
  int res = 0;  // по умолчанию предполагаем, что числа не равны
  if ((num1.bits[0] == num2.bits[0]) &&  // сравнение всех элементов массивов
                                         // битс в структурах обоих чисел
      (num1.bits[1] == num2.bits[1]) && (num1.bits[2] == num2.bits[2]) &&
      (num1.bits[3] == num2.bits[3])) {
    res = 1;  // если все элементы массивов равны
  }
  return res;
}

void set_bit1(s21_decimal *num,
              int ind) {  // указатель на структуру децимал и индекс бита,
                          // который нужно установить
  int arr_ind =
      ind /
      32;  // вычисление индекса массива (0, 1, 2, 3) в котором находится бит
  int bit_displace = ind % 32;  // вычисление сдвига внутри этого массива
  num->bits[arr_ind] |=
      1u << bit_displace;  // установление нужного бита в значение 1 с помощью
                           // побитового ИЛИ
}
/*для установки определенного бита в структуре децимал, еще одна
версия, она нужна для моей функции конвертации из инт в децимал*/

void set_zero(s21_decimal *num) {  // указатель на структуре децимал
  memset(
      &(num->bits), 0,
      sizeof(num->bits));  // фукции для получения адреса масива битс в
                           // структуре децимал и передачи его в мемсет, сайзоф
                           // указывает количество байтов для заполнения
}
/*для заполнения всех битов с структуре децимал нулями,
нужно чтобы сбросить значение в структуре для ее дальнейшего
использования - установки нового значения*/

int s21_from_float_string(
    int whole, float fraction,
    s21_decimal *
        value) {  // принимает целую, дробную части числа и указатель на область
                  // памяти, куда будет записан результат преобразований
  char fraction_string[255] = {0};  // строка для хранения дробной части числа
  char integer_string[255] = {0};  // строка для хранения целой части числа
  int position = 0;  // для хранения текущей позиции в строке
  int exponent =
      0;  // экспонента (скейл) (количество десятичных знаков после запятой)
  if (fraction != 0.0)
    sprintf(fraction_string, "%.9f",
            fraction);  // преобразование дробной части в строку, проверка на
                        // неравеноство нулю, иначе, если равна нулю - ее
                        // преобразование не имеет смысла, форматирование до 9
                        // знаков после запятой - для точности в дальнейших
                        // преобразованиях
  if (whole != 0.0)
    sprintf(integer_string, "%d",
            whole);  // преобразование целой части в строку
  memmove(
      fraction_string, fraction_string + 2,
      strlen(
          fraction_string));  // удаление 0. из строки с дробной частью, именно
                              // для этого +2, указаны адрес назначения куда
                              // копировать, источник, откуда копировать и
                              // количество байтов для копирования
  exponent =
      strlen(integer_string);  // экспонента равна длине целой(!!!)
                               // части, это нужно, чтобы потом правильно
                               // определить количество десятичных знаков после
                               // запятой при преобразовании в децимал
  strcat(integer_string,
         fraction_string);  // объединение целой и дробной частей (обратить
                            // внимание на конец этого куска кода, где будет
                            // рассчитана экспонента)
  size_t position_sign_number =
      strlen(integer_string);  // длина объединенной строки (т.е. здесь
                               // integer_string уже ОБЪЕДИНЕННАЯ строка!!!)
  position =
      position_sign_number;  // установка текущей позиции как длины строки
  if (position_sign_number > 7 &&
      strlen(fraction_string) > 0) {  // обрезка до 7 знаков и округление
    while (position != 7)
      integer_string[position--] =
          '\0';  // уменьшаем позицию и обрезаем строку до 7 знаков, чтобы
                 // сохранить точность числа в пределах, допустимых для
                 // преставления в децимал
    if ((int)integer_string[position] - '0' >
        4) {       // проверка, нужно ли округлять
      position--;  // переход к предыдущему символу, который и нужно округлить
      if (integer_string[position] ==
          '9') {  // если текущий символ 9 и он долже быть округлен до 0, а
                  // предыдущая цифра должна быть увеличена на единицу
        while (integer_string[position] == '9')
          integer_string[position--] = '0';  // замена текущего символа на 0,
                                             // переход на предыдущую позицию
        integer_string[position]++;  // увеличение символа в предыдущей позиции
      } else
        integer_string[position]++;  // иначе просто увеличиваем на единицу
      integer_string[7] = '\0';  // завершение строки после 7 знаков
      position = strlen(integer_string) -
                 1;  // установление индекса последнего символа, не включая
                     // завершающий символ конца строки
      while (position >= 0 && integer_string[position] == '0')
        integer_string[position--] =
            '\0';  // удаление завершающих (лишних)нулей, замена их символом
                   // конца строки, пример замена 123.4000 на 123.4
    } else
      while (position >= 0 && integer_string[position] == '0')
        integer_string[position--] = '\0';  // удаление завершающих нулей,
                                            // замена их символом конца строки
  }
  exponent = (strlen(integer_string) -
              exponent);  // установка количества знаков после запятой, пересчет
                          // экспоненты как разница между ПОЛНОЙ(целой
                          // и дробной) длиной указанной строки и начальным
                          // значением экспоненты, например, если в
                          // integer_string 12345 (5), а экспонента изначально
                          // равна 3, то, новая экспонета будет равна 5 - 3 = 2,
  set_scale(value,
            exponent);  // установит затем эту экспоненту, в данном примере - 2
                        // знака после запятой, получится 123.45
  return atoi(
      integer_string);  // возвращение целочисленного значения строки это будет
                        // нужно для дальнейшего выполнеия основной функции
}
/*для преобразования целового и дробного числа, разделенных
на отдельные элементы в строковое представление, затем
оно используется для создания числа децимал
Важное пояснение по поводу экспоненты в конце из integer_string,
которая стала объединенной строкой из дробной и целой частей, вычитается
экспонента - установленное в длину первоначальной integer_string
как длины только целой части*/

// сложение всех bits в big_decimal друг с другом с обработкой переполнений
void add_big_bits(s21_big_decimal big_value_1, s21_big_decimal big_value_2,
                  s21_big_decimal *result) {
  uint64_t overflow = 0;  // для хранения переполнения при сложении
  for (int i = 0; i < 7; i++) {
    result->bits[i] = big_value_1.bits[i] + big_value_2.bits[i] +
                      overflow;  // сложение элементов и добавление переполнения
    overflow = ((HIGHBITS & result->bits[i]) >>
                32);  // вычисление переполнеия если результат превышает 32 бита
  }
  for (int i = 0; i < 7; i++) {
    result->bits[i] &= LOWBITS;  // оставляем только 32 элемента
  }
}

// вычитание битс через сложение
void subtract_big_bits(s21_big_decimal val_1, s21_big_decimal val_2,
                       s21_big_decimal *result) {
  make_bid_decimal_compliment(&val_2);  // инвертируем второе число
  add_big_bits(val_1, val_2, result);  // и складываем биты
}

// проверяет, вместится ли биг децимал в децимал
int does_big_fit_into_decimal(s21_big_decimal b_dec) {
  for (int i = 3; i < 7; i++) {
    if (b_dec.bits[i] != 0) return 0;
  }
  return 1;
}

// проверяет, является ли биг децимал нулем
int is_big_zero(s21_big_decimal b_dec) {
  for (int i = 0; i < 7; i++) {
    if (b_dec.bits[i] != 0)
      return 0;  // если 3-6 элемент не равны нулю, число слишком большое, чтобы
                 // влезть в децимал
  }
  return 1;
}

// сдвигает биг децимал на определенное количество бит влево
s21_big_decimal shift_big_left(s21_big_decimal b_dec, int shift) {
  for (int i = 0; i < shift; i++) {
    for (int j = 0; j < 7; j++) {
      b_dec.bits[j] = b_dec.bits[j] << 1;
    }
    handle_overflow(&b_dec);
  }
  return b_dec;
}