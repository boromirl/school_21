#include "../s21_decimal.h"

int s21_from_decimal_to_float(
    s21_decimal src,
    float *dst) {  // исходное число типа децимал, указатель на переменную куда
                   // будет записан результат преобразования
  double result =
      0;  // переменная для хранения промежуточного результата в виде double,
          // для большей точности и избегания переполнения
  int scale =
      get_scale(src);  // для хранения смещения десятичной точки, т.е. для
                       // скейла, которая извлекается из структуры децимал,
                       // скейл определяет, насколько нужно сдвинуть
                       // десятичную точку, чтобы получить верное значение числа
  for (int i = 0; i < 96; i++) {  // цикл по всем 96 битам числа децимал
    int shift = i % 32;  // для вычисления сдвига внутри текущего 32 битного
                         // элемента (т.е. от 0 до 31 бита)
    if ((src.bits[i / 32] & 1U << shift) !=
        0) {  // проверка, установлен ли бит в позиции shift в текущем элементе,
              // выбирает конкретный бит в элементе, создает маску с одним битом
              // в позиции shiftБ применяет побитовое и к текущему элементу и
              // маске, чтобы проверить установлен ли бит (0 или 1)
      result += pow(2, i);  // если бит установлен, то его значение добавляется
                            // к result (определяется как 2 в степени i (от 0 до
                            // 31)), пример 1010 переводим в десятичную = 0 *
                            // 2^0 + 1 * 2^1 + 0 * 2^2 + 1 * 2^3 = 10
    }
  }
  if (get_scale(src) >
      0) {  // сдвиг десятичной точки в числе src, сначала извлечение скейоа -
            // побитовое и между 4-м элементом и маской, а затем сдвиг вправо на
            // 16 бит, чтобы получить значение скейла и проверка является ли
            // значение скейла больше нуля,
    for (int i = scale; i > 0;
         i--) {  // цикл на какое количество позиций нужно сдвинуть точку,
                 // например, если скейл 3 (т.е. 10 в 3 степени), значит
                 // итерацию нужно повторить 3 раза, т.е. три раза разделить
                 // число 10^3 степени на 10
      result /=
          10.0;  // затем каждая единица скейл делится на 10, чтобы правильно
                 // выровнять десятичную точку, т.е. каждый раз точка сдвигается
                 // вправо на 1 позицию, пример, если скейл = 3, то делим 10 из
                 // предыдущего примера на 10.0 3 раза, т.е. 10 / 10.0^3 = 0.01
    }
  }
  *dst = (float)result;  // результат преобразования result приводится к типу
                         // флоат и записывается в память по указателю dst
  if (get_sign(&src))
    *dst *= -1;  // проверяет знак числа src и если оно было отрицательным, то
                 // dst умножается на -1, чтобы тоже сделать его отрицательным
  //*dst *= src.bits[3] >> 31 ? -1 : 1; - это первоначальная реализация // для
  //установки значения бита, сдвиг его на 31 позицию, чтобы узнать знак числа
  //получаем 0 - положительное или 1 отрицательное, отрицательное - умножаем на
  //-1, если положительное - умножаем на 1
  return 0;
}
/*для преобразования типа децимал в тип флоат*/
